# -------------------- app.py --------------------
import streamlit as st
import datetime
import requests
from bs4 import BeautifulSoup
from dotenv import load_dotenv
import os
import json
import httpx
from fpdf import FPDF
from docx import Document
import time
import pandas as pd

# -------------------- Configura√ß√µes Iniciais --------------------
st.set_page_config(page_title="Sistema Jur√≠dico", layout="wide")
load_dotenv()

# Configura√ß√£o da API DeepSeek
DEEPSEEK_API_KEY = "sk-4cd98d6c538f42f68bd820a6f3cc44c9"
DEEPSEEK_ENDPOINT = "https://api.deepseek.com/v1/chat/completions"

# Configura√ß√£o do Google Apps Script
GAS_WEB_APP_URL = "https://script.google.com/macros/s/AKfycbzx0HbjObfhgU4lqVFBI05neopT-rb5tqlGbJU19EguKq8LmmtzkTPtZjnMgCNmz8OtLw/exec"

# Dados do sistema
USERS = {
    "dono": {"senha": "dono123", "papel": "owner"},
    "gestor1": {"senha": "gestor123", "papel": "manager", "escritorio": "Escritorio A"},
    "adv1": {"senha": "adv123", "papel": "lawyer", "escritorio": "Escritorio A", "area": "C√≠vel"},
}

# -------------------- Fun√ß√µes Auxiliares --------------------
def converter_prazo(prazo_str):
    """
    Converte uma string no formato ISO ("YYYY-MM-DD") para um objeto date.
    Se o valor for nulo ou estiver em formato inv√°lido, retorna a data de hoje.
    """
    if not prazo_str:
        return datetime.date.today()
    try:
        return datetime.date.fromisoformat(prazo_str)
    except ValueError:
        st.warning(f"Formato de data inv√°lido: {prazo_str}. Utilizando a data de hoje.")
        return datetime.date.today()

# -------------------- Integra√ß√£o com Google Sheets --------------------
def enviar_dados_para_planilha(tipo, dados):
    """
    Envia os dados para o Google Sheets via Google Apps Script.
    Retorna True se a resposta for "OK", caso contr√°rio False.
    """
    try:
        payload = {"tipo": tipo, **dados}
        response = requests.post(
            GAS_WEB_APP_URL,
            data=json.dumps(payload),
            headers={'Content-Type': 'application/json'}
        )
        return response.text.strip() == "OK"
    except Exception as e:
        st.error(f"‚ùå Erro ao enviar dados ({tipo}): {e}")
        return False

def carregar_dados_da_planilha(tipo, debug=False):
    """
    Carrega os dados do Google Sheets para o tipo especificado.
    Se debug=True, exibe informa√ß√µes da URL e parte da resposta.
    """
    try:
        response = requests.get(GAS_WEB_APP_URL, params={"tipo": tipo})
        response.raise_for_status()
        if debug:
            st.text(f"üîç URL chamada: {response.url}")
            st.text(f"üìÑ Resposta bruta: {response.text[:500]}")
        return response.json()
    except json.JSONDecodeError:
        st.error(f"‚ùå Resposta inv√°lida para o tipo '{tipo}'. O servidor n√£o retornou JSON v√°lido.")
        return []
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Erro ao carregar dados ({tipo}): {e}")
        return []

# -------------------- Fun√ß√µes do Sistema --------------------
def login(usuario, senha):
    """Autentica o usu√°rio no sistema com base no dicion√°rio USERS."""
    user = USERS.get(usuario)
    return user if user and user["senha"] == senha else None

def calcular_status_processo(data_prazo, houve_movimentacao):
    """
    Calcula o status do processo com base na data final e se houve movimenta√ß√£o.
    Retorna:
      - "üîµ Movimentado" se houve movimenta√ß√£o;
      - "üî¥ Atrasado" se o prazo j√° passou;
      - "üü° Aten√ß√£o" se faltam 10 ou menos dias;
      - "üü¢ Normal" caso contr√°rio.
    """
    hoje = datetime.date.today()
    dias_restantes = (data_prazo - hoje).days
    if houve_movimentacao:
        return "üîµ Movimentado"
    elif dias_restantes < 0:
        return "üî¥ Atrasado"
    elif dias_restantes <= 10:
        return "üü° Aten√ß√£o"
    else:
        return "üü¢ Normal"

def consultar_movimentacoes_simples(numero_processo):
    """
    Consulta movimenta√ß√µes processuais simuladas para o n√∫mero do processo informado.
    Retorna uma lista com at√© 5 movimenta√ß√µes ou uma mensagem caso n√£o sejam encontradas.
    """
    url = f"https://esaj.tjsp.jus.br/cpopg/show.do?processo.codigo={numero_processo}"
    r = requests.get(url)
    soup = BeautifulSoup(r.text, "html.parser")
    andamentos = soup.find_all("tr", class_="fundocinza1")
    return [a.get_text(strip=True) for a in andamentos[:5]] if andamentos else ["Nenhuma movimenta√ß√£o encontrada"]

def gerar_peticao_ia(prompt, temperatura=0.7, max_tokens=2000, tentativas=3):
    """
    Gera uma peti√ß√£o utilizando a API DeepSeek com tratamento de timeout e tentativas.
    """
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {DEEPSEEK_API_KEY}"
    }
    payload = {
        "model": "deepseek-chat",
        "messages": [
            {
                "role": "system",
                "content": "Voc√™ √© um assistente jur√≠dico especializado. Responda com linguagem t√©cnica formal."
            },
            {
                "role": "user",
                "content": prompt
            }
        ],
        "temperature": temperatura,
        "max_tokens": max_tokens
    }
    for tentativa in range(tentativas):
        try:
            start_time = time.time()
            with httpx.Client(timeout=30) as client:
                response = client.post(DEEPSEEK_ENDPOINT, headers=headers, json=payload)
            response_time = time.time() - start_time
            st.sidebar.metric("Tempo de resposta API", f"{response_time:.2f}s")
            response.raise_for_status()
            resposta_json = response.json()
            if not resposta_json.get('choices'):
                raise ValueError("Resposta da API incompleta")
            return resposta_json['choices'][0]['message']['content']
        except httpx.ReadTimeout:
            if tentativa < tentativas - 1:
                st.warning(f"Tentativa {tentativa + 1} falhou (timeout). Tentando novamente...")
                continue
            else:
                raise Exception("O servidor demorou muito para responder ap√≥s v√°rias tentativas")
        except httpx.HTTPStatusError as e:
            error_msg = f"Erro HTTP {e.response.status_code}"
            if e.response.status_code == 402:
                error_msg += " - Saldo insuficiente na API"
            raise Exception(f"{error_msg}: {e.response.text}")
        except Exception as e:
            if tentativa == tentativas - 1:
                raise Exception(f"Erro na requisi√ß√£o: {str(e)}")
            continue
    return "‚ùå Falha ao gerar peti√ß√£o ap√≥s m√∫ltiplas tentativas"

def exportar_pdf(texto, nome_arquivo="peticao"):
    """
    Exporta o texto informado para um arquivo PDF.
    """
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.multi_cell(0, 10, texto)
    pdf.output(f"{nome_arquivo}.pdf")
    return f"{nome_arquivo}.pdf"

def exportar_docx(texto, nome_arquivo="peticao"):
    """
    Exporta o texto informado para um arquivo DOCX.
    """
    doc = Document()
    doc.add_paragraph(texto)
    doc.save(f"{nome_arquivo}.docx")
    return f"{nome_arquivo}.docx"

def gerar_relatorio_pdf(dados, nome_arquivo="relatorio"):
    """
    Gera um relat√≥rio em PDF com uma tabela contendo os dados dos processos.
    """
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    # T√≠tulo do relat√≥rio
    pdf.cell(200, 10, txt="Relat√≥rio de Processos", ln=1, align='C')
    pdf.ln(10)
    # Cabe√ßalho da tabela
    col_widths = [40, 30, 50, 30, 40]
    headers = ["Cliente", "N√∫mero", "√Årea", "Status", "Respons√°vel"]
    for i, header in enumerate(headers):
        pdf.cell(col_widths[i], 10, txt=header, border=1)
    pdf.ln()
    # Linhas da tabela
    for processo in dados:
        prazo = converter_prazo(processo.get("prazo"))
        status = calcular_status_processo(prazo, processo.get("houve_movimentacao", False))
        cols = [
            processo.get("cliente", ""),
            processo.get("numero", ""),
            processo.get("area", ""),
            status,
            processo.get("responsavel", "")
        ]
        for i, col in enumerate(cols):
            pdf.cell(col_widths[i], 10, txt=str(col), border=1)
        pdf.ln()
    pdf.output(f"{nome_arquivo}.pdf")
    return f"{nome_arquivo}.pdf"

def aplicar_filtros(dados, filtros):
    """
    Aplica os filtros informados aos dados.
    """
    resultados = dados.copy()
    for campo, valor in filtros.items():
        if valor:
            if campo == "data_inicio":
                resultados = [r for r in resultados if datetime.date.fromisoformat(r["data_cadastro"][:10]) >= valor]
            elif campo == "data_fim":
                resultados = [r for r in resultados if datetime.date.fromisoformat(r["data_cadastro"][:10]) <= valor]
            else:
                resultados = [r for r in resultados if str(valor).lower() in str(r.get(campo, "")).lower()]
    return resultados

def verificar_movimentacao_manual(numero_processo):
    """
    Realiza a verifica√ß√£o manual das movimenta√ß√µes do processo especificado.
    """
    with st.spinner(f"Verificando movimenta√ß√µes para o processo {numero_processo}..."):
        time.sleep(2)  # Simula tempo de consulta
        return consultar_movimentacoes_simples(numero_processo)

def obter_processos_por_usuario(papel, escritorio=None, area=None):
    """
    Filtra os processos com base no papel do usu√°rio e, se aplic√°vel, pelo escrit√≥rio e √°rea.
    """
    processos = carregar_dados_da_planilha("Processo") or []
    if papel == "owner":
        return processos
    elif papel == "manager":
        return [p for p in processos if p.get("escritorio") == escritorio]
    elif papel == "lawyer":
        return [p for p in processos if p.get("escritorio") == escritorio and p.get("area") == area]
    else:
        return []

# -------------------- Interface Principal --------------------
def main():
    st.title("Sistema Jur√≠dico com DeepSeek AI")
    
    # Carregar dados do Google Sheets
    CLIENTES = carregar_dados_da_planilha("Cliente") or []
    PROCESSOS = carregar_dados_da_planilha("Processo") or []
    ESCRITORIOS = carregar_dados_da_planilha("Escritorio") or []
    HISTORICO_PETICOES = carregar_dados_da_planilha("Historico_Peticao") or []
    FUNCIONARIOS = carregar_dados_da_planilha("Funcionario") or []
    
    # Sidebar: Login
    with st.sidebar:
        st.header("üîê Login")
        usuario = st.text_input("Usu√°rio")
        senha = st.text_input("Senha", type="password")
        if st.button("Entrar"):
            user = login(usuario, senha)
            if user:
                st.session_state.usuario = usuario
                st.session_state.papel = user["papel"]
                st.session_state.dados_usuario = user
                st.success("Login realizado com sucesso!")
            else:
                st.error("Credenciais inv√°lidas")
    
    # Conte√∫do principal ap√≥s login
    if "usuario" in st.session_state:
        papel = st.session_state.papel
        escritorio_usuario = st.session_state.dados_usuario.get("escritorio")
        area_usuario = st.session_state.dados_usuario.get("area")
        st.sidebar.success(f"Bem-vindo, {st.session_state.usuario} ({papel})")
        
        # Menu Principal
        opcoes = ["Dashboard", "Clientes", "Processos", "Peti√ß√µes IA", "Hist√≥rico", "Relat√≥rios"]
        if papel == "owner":
            opcoes.extend(["Gerenciar Escrit√≥rios", "Gerenciar Funcion√°rios"])
        elif papel == "manager":
            opcoes.extend(["Gerenciar Funcion√°rios"])
        escolha = st.sidebar.selectbox("Menu", opcoes)
        
        # Dashboard
        if escolha == "Dashboard":
            st.subheader("üìã Painel de Controle de Processos")
            with st.expander("üîç Filtros", expanded=True):
                col1, col2, col3 = st.columns(3)
                with col1:
                    filtro_area = st.selectbox("√Årea", ["Todas"] + list(set(p["area"] for p in PROCESSOS)))
                with col2:
                    filtro_status = st.selectbox("Status", ["Todos", "üü¢ Normal", "üü° Aten√ß√£o", "üî¥ Atrasado", "üîµ Movimentado"])
                with col3:
                    filtro_escritorio = st.selectbox("Escrit√≥rio", ["Todos"] + list(set(p["escritorio"] for p in PROCESSOS)))
            
            processos_visiveis = obter_processos_por_usuario(papel, escritorio_usuario, area_usuario)
            if filtro_area != "Todas":
                processos_visiveis = [p for p in processos_visiveis if p.get("area") == filtro_area]
            if filtro_escritorio != "Todos":
                processos_visiveis = [p for p in processos_visiveis if p.get("escritorio") == filtro_escritorio]
            if filtro_status != "Todos":
                processos_visiveis = [
                    p for p in processos_visiveis
                    if calcular_status_processo(converter_prazo(p.get("prazo")), p.get("houve_movimentacao", False)) == filtro_status
                ]
            
            # M√©tricas Resumidas
            st.subheader("üìä Vis√£o Geral")
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("Total Processos", len(processos_visiveis))
            with col2:
                st.metric("Atrasados", len([
                    p for p in processos_visiveis
                    if calcular_status_processo(converter_prazo(p.get("prazo")), p.get("houve_movimentacao", False)) == "üî¥ Atrasado"
                ]))
            with col3:
                st.metric("Para Aten√ß√£o", len([
                    p for p in processos_visiveis
                    if calcular_status_processo(converter_prazo(p.get("prazo")), p.get("houve_movimentacao", False)) == "üü° Aten√ß√£o"
                ]))
            with col4:
                st.metric("Movimentados", len([p for p in processos_visiveis if p.get("houve_movimentacao", False)]))
            
            st.subheader("üìã Lista de Processos")
            if processos_visiveis:
                df = pd.DataFrame(processos_visiveis)
                df['Status'] = df.apply(lambda row: calcular_status_processo(
                    converter_prazo(row.get("prazo")), row.get("houve_movimentacao", False)
                ), axis=1)
                status_order = {"üî¥ Atrasado": 0, "üü° Aten√ß√£o": 1, "üü¢ Normal": 2, "üîµ Movimentado": 3}
                df['Status_Order'] = df['Status'].map(status_order)
                df = df.sort_values('Status_Order').drop('Status_Order', axis=1)
                st.dataframe(df[['Status', 'numero', 'cliente', 'area', 'prazo', 'responsavel']])
                
                st.subheader("üîç Consulta Manual de Processo")
                with st.form("consulta_processo"):
                    num_processo = st.text_input("N√∫mero do Processo para Consulta")
                    if st.form_submit_button("Verificar Movimenta√ß√µes"):
                        if num_processo:
                            movimentacoes = verificar_movimentacao_manual(num_processo)
                            st.subheader(f"Movimenta√ß√µes do Processo {num_processo}")
                            for mov in movimentacoes:
                                st.write(f"- {mov}")
                        else:
                            st.warning("Por favor, insira um n√∫mero de processo")
            else:
                st.info("Nenhum processo encontrado com os filtros aplicados")
        
        # Cadastro de Clientes
        elif escolha == "Clientes":
            st.subheader("üë• Cadastro de Clientes")
            with st.form("form_cliente"):
                nome = st.text_input("Nome Completo*", key="nome_cliente")
                email = st.text_input("E-mail*")
                telefone = st.text_input("Telefone*")
                aniversario = st.date_input("Data de Nascimento")
                escritorio = st.selectbox("Escrit√≥rio", [e["nome"] for e in ESCRITORIOS] + ["Outro"])
                observacoes = st.text_area("Observa√ß√µes")
                if st.form_submit_button("Salvar Cliente"):
                    if not nome or not email or not telefone:
                        st.warning("Campos obrigat√≥rios (*) n√£o preenchidos!")
                    else:
                        novo_cliente = {
                            "nome": nome,
                            "email": email,
                            "telefone": telefone,
                            "aniversario": aniversario.strftime("%Y-%m-%d"),
                            "observacoes": observacoes,
                            "cadastro": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "responsavel": st.session_state.usuario,
                            "escritorio": escritorio
                        }
                        if enviar_dados_para_planilha("Cliente", novo_cliente):
                            CLIENTES.append(novo_cliente)
                            st.success("Cliente cadastrado com sucesso!")
        
        # Gest√£o de Processos
        elif escolha == "Processos":
            st.subheader("üìÑ Gest√£o de Processos")
            with st.form("form_pro_
